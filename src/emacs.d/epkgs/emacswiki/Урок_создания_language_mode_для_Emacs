Оригинальный урок, написанный ScottAndrewBorton, доступен по адресу: * ##http://two-wugs.net/emacs/mode-tutorial.html##
Архивная копия опубликована ниже. //Но сначала// несколько слов от автора.

[new]
Мне довелось разработать несколько режимов редактирования для различных экзотических или самодельных языков программирования. Взявшись за это дело впервые, я столкнулся с нехваткой учебных материалов, легко и доступно объясняющих, как пишутся языковые режимы для Emacs. Даже в книге ''Writing GNU Emacs Extensions'' ISBN: 1565922611 не раскрываются такие темы, как подсветка синтаксиса и отступы. А ##generic-mode##, поставляемый в комплекте с последними версиями Emacs, не умеет работать с отступами

Здесь изложение построено на примере моего [[wpdl-mode.el]], режима редактирования для языка [http://www.wfmc.org Workflow Process Definition Language]. Я рассматриваю содержание файла [[wpdl-mode.el]] строка за строкой и объясняю, что каждая из них делает. Для лучшего понимания того, что должно получиться в результате, может быть полезен пример программы на языке WPDL: [[[ex1-wpd.txt]]]. Представляется, что ##wpdl-mode## достаточно прост и ясен, чтобы на его примере вы смогли усвоить основы разработки режимов редактирования Emacs.

Готовя этот текст, я ориентировался на GNU Emacs версий 20 и 21. '''Обязан предупредить''', что поскольку я не являюсь профессиональным Emacs-хакером, вы рискуете оказаться в ситуации с условным названием "слепой ведет слепого". Более опытные коллеги могут иметь претензии к стилю или терминологии, - надеюсь они помогут устранить следы моего дилетантизма (от переводчика: e-mail для связи с автором см. на англоязычной странице). Благодарю читателей с [[comp.emacs]] и [[gnu.emacs.help]] за ценные советы! -- ScottAndrewBorton

==Базовая настройка==
{{{
(defvar wpdl-mode-hook nil)
}}}
Сначала определим переменные, необходимые для любого режима редактирования. ‘wpdl-mode-hook’ позволяет пользователям запускать их собственный код в рамках данного режима.
{{{
(defvar wpdl-mode-map
  (let ((map (make-keymap)))
    (define-key map "\C-j" 'newline-and-indent)
    map)
  "Keymap for WPDL major mode")
}}}
Здесь создается клавиатурная раскладка. Она называется ‘wpdl-mode-map’ и позволяет вам и вашим пользователям определять специализированные для данного режима сочетания клавиш. Сразу после создания новая раскладка совпадает с базово-умолчательной в Emacs. Используя ‘define-key’, мы переопределяем клавишное сочетание Control-j, которое теперь означает ‘newline-and-indent’ (на самом деле это сочетание совпадает с умолчательным и взято здесь просто для примера). Разумеется, вы можете определить столько клавиатурных привязок, сколько пожелаете. Если же вы хотите переназначить лишь небольшое количество сочетаний, возможно, вы скорее захотите воспользоваться функцией ‘make-sparse-keymap’ вместо ‘make-keymap’.
{{{
;;;###autoload
(add-to-list 'auto-mode-alist '("\\.wpd\\'" . wpdl-mode))
}}}
Здесь мы регистрируем свой режим в ‘auto-mode-alist’. Теперь, когда в какой-либо текстовый буфер будет загружен файл, название которого заканчивается на ".wpd", Emacs назначит для этого буфера режим редактирования wpdl-mode. Некоторые режимы оставляют данный шаг на откуп пользователю.

==Подсветка ключевых слов==
{{{
(defconst wpdl-font-lock-keywords-1
  (list
   '("\\<\\(A\\(CTIVITY\\|PPLICATION\\)\\|DATA\\|END_\\(A\\(CTIVITY\\|PPLICATION\\)\\|DATA\\|MODEL\\|PARTICIPANT\\|T\\(OOL_LIST\\|RANSITION\\)\\|WORKFLOW\\)\\|MODEL\\|PARTICIPANT\\|T\\(OOL_LIST\\|RANSITION\\)\\|WORKFLOW\\)\\>" . font-lock-builtin-face)
   '("\\('\\w*'\\)" . font-lock-variable-name-face))
  "Minimal highlighting expressions for WPDL mode")
}}}
Это мы определили минимальный набор ключевых слов для подсветки. Переменная ‘font-lock-keyword’ представляет собой список ключевых слов для подсветки. Есть много способов организации этого списка, в данном случае он представляет собой список пар ##(шаблон . шрифт)##.
В данном списке 2 элемента: первый определяет ключевые слова языка WPDL, второй - шаблон именования идентификаторов (например, переменных). Для каждого типа ключевых слов я назначил соответствующий шрифт (‘font-lock-builtin-face’ и ‘font-lock-variable-name-face’).
Для своего списка ключевых слов я выбрал те, от выделения которых исходный код выигрывает более всего - те, которые служат для разделения блоков информации. Можно заметить, что регулярные выражения, идентифицирующие ключевые слова, оптимизированы. Мне не пришлось делать этого вручную. Emacs предоставляет функцию ‘regexp-opt’, чтобы уберечь вас от нудного написания сложных регулярных выражений. ‘regexp-opt’ принимает список строк и дополнительный необязательный аргумент. Этот последний аргумент определяет, желаем ли мы заключить результирующее регулярное выражение в скобки. В данном случае мы этого хотим. Например, вычисление такого выражения:
{{{
(regexp-opt '("PARTICIPANT" "END_PARTICIPANT" "MODEL" "END_MODEL"
"WORKFLOW" "END_WORKFLOW" "ACTIVITY" "END_ACTIVITY" "TRANSITION"
"END_TRANSITION" "APPLICATION" "END_APPLICATION" "DATA" "END_DATA"
"TOOL_LIST" "END_TOOL_LIST") t)
}}}
приведет к следующему результату:
{{{"\\(A\\(CTIVITY\\|PPLICATION\\)\\|DATA\\|END_\\(A\\(CTIVITY\\|PPLICATION\\)\\|DATA\\|MODEL\\|PARTICIPANT\\|T\\(OOL_LIST\\|RANSITION\\)\\|WORKFLOW\\)\\|MODEL\\|PARTICIPANT\\|T\\(OOL_LIST\\|RANSITION\\)\\|WORKFLOW\\)"
}}}
Поскольку интеллектуальная подсветка текста - задача крайне ресурсоемкая, оптимизация регулярных выражений может привести к выигрышу в производительности.
И наконец, рег. выражения заключены в угловые скобки. Это означает, что выражение соответствует подстроке, только если последняя окружена специальными символами, в роли которых могут выступать: пробел, табуляция, начало файла, конец файла. Это, например, предохраняет от подсветки слог ##if## в слове ##difference##.
{{{
(defconst wpdl-font-lock-keywords-2
  (append wpdl-font-lock-keywords-1
		  (list
		   '("\\<\\(AUTHOR\\|C\\(ONDITION\\|REATED\\)\\|DE\\(FAULT_VALUE\\|SCRIPTION\\)\\|EXTENDED_ATTRIBUTE\\|FROM\\|I\\(MPLEMENTATION\\|N_PARAMETERS\\)\\|JOIN\\|NAME\\|O\\(THERWISE\\|UT_PARAMETERS\\)\\|PERFORMER\\|ROUTE\\|S\\(PLIT\\|TATUS\\)\\|T\\(O\\(OLNAME\\)?\\|YPE\\)\\|VENDOR\\|WPDL_VERSION\\)\\>" . font-lock-keyword-face)
		   '("\\<\\(TRUE\\|FALSE\\)\\>" . font-lock-constant-face)))
  "Additional Keywords to highlight in WPDL mode")
}}}
Теперь я определил второй уровень подсветки. Обратите внимание, что второй уровень присоединен к первому, и таким образом хранит шаблоны всех ключевых слов на обоих уровнях. Здесь я определил еще больше ключевых слов и две встроенных константы язака WPDL - TRUE и FALSE.
{{{
(defconst wpdl-font-lock-keywords-3
  (append wpdl-font-lock-keywords-2
		  (list
		   '("\\<\\(A\\(ND\\|PPLICATIONS\\)\\|BOOLEAN\\|HUMAN\\|INTEGER\\|NO\\|OR\\(GANISATIONAL_UNIT\\)?\\|R\\(EFERENCE\\|OLE\\)\\|S\\(TRING\\|YNCHR\\)\\|UNDER_REVISION\\|WORKFLOW\\|XOR\\)\\>" . font-lock-constant-face)))
  "Balls-out highlighting in WPDL mode")
}}}
Добавляем другие константы WPDL. На этом закончим со списками ключевых слов.
{{{
(defvar wpdl-font-lock-keywords wpdl-font-lock-keywords-3
  "Default highlighting expressions for WPDL mode")
}}}
Здесь я назначил список для подсветки по умолчанию - самый широкий. Это просто мое предпочтение, пользователю разрешается изменить значение этой переменной (если, конечно, он знает, как! Возможно, об этом следует написать в документации к вашему режиму редактирования.).
==Отступы==
У WPDL Pascal-образный синтаксис. Схема применения отступов соответствующая - блоки информации сдвигаются вправо относительно родительских блоков. К счастью организовать такую схему средствами Emacs совсем не трудно - всего 28 строк кода. Вот пример WPDL-кода с отступами:
{{{
WORKFLOW	'In_the_Mail_Room'
    CREATED	1998-07-15
    NAME	"In the Mail Room"

    ACTIVITY	'MailRoom'
        NAME	"Mail Room"
        TOOL_LIST 
            'scan_document'
            'identify_document'
            'send_document'
        END_TOOL_LIST
        PERFORMER 'Joe'
    END_ACTIVITY

END_WORKFLOW
}}}
Я определил пять правил для отступов. Вот они:
* Если мы находимся в начале буфера, отступить на 0 колонок.
* Если мы находимся на строке, начинающейся на ##END_##, отступить 1 раз влево.
* Если мы //сразу// перед данной строкой находится строка ##END_##, назначить для данной строки тот же отступ, что и для строки ##END_##.
* Если мы //сразу// перед данной строкой находится начало блока, например строка ##PARTISIPANT##, отступить данной строкой вправо от предыдущей.
* В остальных случаях не делать отступов.
Следующий пример на WPDL может пояснить сказанное:
{{{
// My activity              // Rule 1 applies
ACTIVITY    'MailRoom'      // Rule 5 applies
    NAME    "Mail Room"     // Rule 4 (based on "ACTIVITY")
    TOOL_LIST               // Rule 4 (based on "ACTIVITY")
        'scan_document'     // Rule 4 (based on "TOOL_LIST")
        'identify_document' // Rule 4 (based on "TOOL_LIST")
        'send_document'     // Rule 4 (based on "TOOL_LIST")
    END_TOOL_LIST           // Rule 2
    PERFORMER 'Joe'         // Rule 3
END_ACTIVITY                // Rule 2
}}}
{{{
(defun wpdl-indent-line ()
  "Indent current line as WPDL code"
  (interactive)
  (beginning-of-line)
}}}
Начнем с функции, определяющей, какой отступ должен быть применен к данной строке. Полезно сделать эту функцию интерактивной, чтобы по мере разработки было удобно ее тестировать. Интерактивную функцию можно вызвать напрямую: 'M-x your-function'. Также мы перемещаем точку редактирования в начало строки.
{{{
(if (bobp)  ; Check for rule 1
      (indent-line-to 0)
}}}
Здесь мы с помощью функции ##bobp## проверяем, не находимся ли в начале буфера. Если это так, назначаем нулевой отступ. Функция ‘indent-line-to’ сдвигает начало текущей строки в заданную колонку. Обратите внимание, что если это условие срабатывает, то весь последующий код не исполняется.
{{{
(let ((not-indented t) cur-indent)
}}}
Теперь объявляем две переменные. Будем хранить текущее значение отступа в ##cur-indent##. Далее, после проверки всех правил (со второго по пятое), назначаем окончательный отступ.
