;;;
;; I have the following key binding to use them efficiently.
;;
;; (defun my-c++-mode-hook ()
;;   (interactive)
;;   (define-key c++-mode-map (kbd "C-c k f")
;;     'c++-generate-definition-as-kill)
;;   (define-key c++-mode-map (kbd "C-y")
;;     'c++-yank)
;;   ;; other entries removed.
;;   )
;; (add-hook 'c++-mode-hook 'my-c++-mode-hook)


;;;======================================================================
;; interface for the user

(defun c++-generate-definition-as-kill ()
  "generate a class member definition (constructors, functions, static variables) for the declaration before point and put it in kill-ring. After that you can `yank' it to your implementation file. you can also use `c++-yank-member-function' which will indent after yank and place the point nicely.

if this function successfully generated a function, `c++-member-function-killed' will be set to t."
  (interactive)
  (let ((code (c++-generate-definition)))
    (if (null code)
	(message "sorry, code generation failed")
      (kill-new code)
      (setq c++-member-function-killed t)
      (message "definition generated"))))

(defun c++-generate-definition ()
  ;;
  ;; FIXME remove default parameter automatically.
  ;; FIXME static variable not working.
  ;;
  "generate a class member definition (constructors, functions, static variables) for the declaration before point. return the generated code or nil if failed."
  (interactive)
  (let ((class (c++-class-at-point)))
    (if (null class)
	(message "I can't see a class here.")
      (let ((stmt (c++-statement-at-point)))
	(or (c++-generate-definition-for-friend-func stmt)
	    (progn
	      ;; parse class
	      (let ((class-properties (c++-parse-class-name class)))
		(setq template-header (car class-properties))
		(setq class-name (cdr class-properties))
		(if template-header
		    (setq class-name (concat class-name
					     (c++-template-var template-header)))))

	      ;; parse stmt
	
	      (if (c++-funcp stmt)
		  (let ((func-properties (c++-parse-func-declaration stmt)))
		    (setq before-class-name (car func-properties))
		    (setq after-class-name (concat (cdr func-properties)
						   "{\n\n}")))
		;; (if (c++-varp stmt)
		;; else assume it's a var
		(let ((var-properties (c++-parse-var-declaration stmt)))
		  (setq before-class-name (car var-properties))
		  (setq after-class-name (concat (cdr var-properties)
						 " = \n"))))

	      (setq result nil)
	      (if template-header
		  (setq result (concat result
				       template-header "\n")))
	      (if before-class-name
		  (setq result (concat result
				       before-class-name " ")))
	      (concat result
		      class-name "::" after-class-name)))))))

(defun c++-generate-definition-for-friend-func (stmt)
  "this is for consistence only."
  (interactive)
  (and (string-match (concat "^friend"
			     c++-pattern-space
			     "\\([^;]*\\)")
		     stmt)
       (concat (match-string 1 stmt)
	       "{\n\n}")))

(defun c++-yank-definition ()
  "yank the function generated by `c++-generate-definition-from-header-as-kill'"
  (interactive)
  (yank)
  (indent-region (region-beginning) (region-end))
  (forward-line -1)
  ;; if this is not working, use the following
  ;; (indent-according-to-mode)
  (funcall indent-line-function))

(defun c++-yank ()
  "if there is an active generated member function, do `c++-yank-definition', else do a normal `yank'."
  (interactive)
  (if (and (boundp 'c++-member-function-killed)
	   c++-member-function-killed)
      (progn
	(setq c++-member-function-killed nil)
	(c++-yank-member-function))
    (yank)))

;;======================================================================
;; support functions

(setq c++-pattern-id "\\([a-zA-Z_][a-zA-Z_0-9]*\\)")
(setq c++-pattern-id-no-catch "\\(?:[a-zA-Z_][a-zA-Z_0-9]*\\)")
(setq c++-pattern-space "[ 	]+")
(setq c++-pattern-space-optional "[ 	]*")
(setq c++-pattern-space-newline "[ 	\n]+")
(setq c++-pattern-space-newline-optional "[ 	\n]*")

(setq c++-pattern-template
      (concat "\\(template"
	      c++-pattern-space-newline-optional
	      "<"
	      c++-pattern-space-newline-optional
	      "\\(?:"
	      "\\(?:class\\|typename\\)"
	      c++-pattern-space
	      c++-pattern-id-no-catch
	      c++-pattern-space-optional
	      ",?"
	      c++-pattern-space-newline-optional
	      "\\)+"
	      ">\\)"))

(setq c++-pattern-typename
      (concat "\\(?:typename\\|class\\)"
	      c++-pattern-space
	      "\\([^,>]+\\)"))

(setq c++-pattern-constructor
      (concat "^"
	      c++-pattern-id
	      c++-pattern-space-optional
	      "([^;]*"))

;; virtual ~foo();
(setq c++-pattern-destructor
      (concat "^\\(?:virtual"
	      c++-pattern-space-optional
	      "\\)?\\(~"
	      c++-pattern-id
	      c++-pattern-space-optional
	      "([^;]*\\)"))

(setq c++-pattern-operator-optional-no-catch
      "\\(?:++\\|--\\|==\\|!=\\|()\\|+\\|-\\)?")
(setq c++-pattern-function
      (concat "\\(?:"
	      (concat "virtual" c++-pattern-space-newline "\\|")
	      (concat "inline" c++-pattern-space-newline "\\|")
	      "\\)*"
	      "\\(.*\\)"		;return type
	      c++-pattern-space-newline
	      "\\("
	      c++-pattern-id-no-catch
	      c++-pattern-space-optional
	      c++-pattern-operator-optional-no-catch
	      c++-pattern-space-optional
	      "([^;]*\\)"))

(defun c++-in-class-p ()
  "return inclass position from `c-guess-basic-syntax' if point is inside a class. return nil otherwise."
  (let ((syntax (c-guess-basic-syntax)))
    (or (cadr (assoc 'inclass syntax))
	;; when func arguments span over lines or func return type is
	;; in separate line, inclass is not set. but the following are set.
	(if (or (assoc 'arglist-cont-nonempty syntax)
		(assoc 'topmost-intro-cont syntax))
	    (save-excursion
	      (forward-line -1)
	      (c++-in-class-p))))))

(defun c++-class-at-point ()
  "return class name if point is inside a class. return nil otherwise."
  (interactive)
  (let ((inclass (c++-in-class-p)))
    (and inclass
	 (save-excursion
	   (goto-char inclass)
	   ;; inclass could be at beginning of class name or end of class name.
	   ;; depending on whether the user put { on a separate line.
	   (if (looking-at "{")
	       ;; we are at the end of class name
	       (progn
		 (c-beginning-of-statement-1)
		 (buffer-substring-no-properties (point) (1- inclass)))
	     ;; we are at the beginning of class name
	     (c-end-of-statement)
	     (buffer-substring-no-properties inclass (point)))))))

(defun c++-statement-at-point ()
  "return statement at point. return nil if we are at point 1."
  (save-excursion
    (or (looking-back (concat ";" c++-pattern-space-optional))
	(c-end-of-statement))
    (let ((stmt-end (point)))
      (c-beginning-of-statement-1)
      (buffer-substring-no-properties (point) stmt-end))))

(defun c++-parse-class-name (class)
  "return a pair containing template-header and class-name."
  (interactive)
  (and class
       (string-match (concat c++-pattern-space-newline-optional
			     c++-pattern-template "?"
			     c++-pattern-space-newline-optional
			     "class"
			     c++-pattern-space-newline
			     c++-pattern-id)
		     class)
       (cons (match-string 1 class)
	     (match-string 2 class))))

(defun c++-funcp (stmt)
  "return none nil if given statement is a function."
  (and stmt
       (string-match (concat c++-pattern-id
			     c++-pattern-space-optional
			     c++-pattern-operator-optional-no-catch
			     c++-pattern-space-optional
			     "(")
		     stmt)))

(defun c++-parse-func-declaration (stmt)
  "return a pair (return-type . name-and-arguments). or nil if stmt is not func."
  (interactive)
  (and stmt
       (cond
	((string-match c++-pattern-constructor stmt)
	 (cons nil (match-string 0 stmt)))
	((string-match c++-pattern-destructor stmt)
	 (cons nil (match-string 1 stmt)))
	((string-match c++-pattern-function stmt)
	 (cons (match-string 1 stmt)
	       (match-string 2 stmt)))
	(t nil))))

(defun c++-template-var (str)
  "translate \"template <typename T, class U>\" to < T, U >.
return nil if no template var found."
  (interactive)
  ;; add first var to result
  (string-match c++-pattern-typename str)
  (setq result (concat "< " (match-string 1 str)))
  (setq start-from (match-end 0))

  ;; add rest vars to result, separate by comma
  (while (string-match c++-pattern-typename str start-from)
    (setq result (concat result ", " (match-string 1 str)))
    (setq start-from (match-end 0)))

  ;; add final angel bracket
  (concat result " >"))

;; tests for c++-template-var
;; (string-equal "< T, U  >"
;; 	      (c++-template-var "template < typename T, typename U >"))
;; (string-equal "< T, M, U  >"
;; 	      (c++-template-var "template < typename T, class M, class U >"))


