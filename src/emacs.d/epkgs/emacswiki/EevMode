Eev-mode is a tool to let record "executable logs" of what we do in a
format that is reasonably easy to read and to modify, and that lets us
"play back" those logs step by step in any order.

Most steps are either

* [http://angg.twu.net/eev-intros/find-eev-quick-intro.html#3 elisp
  hyperlinks] or
* [http://angg.twu.net/eev-intros/find-eev-quick-intro.html#6 lines to
  be sent to shell-like programs] (in
  "[http://angg.twu.net/eev-intros/find-eev-quick-intro.html#6 eepitch
  blocks]").

[https://www.youtube.com/watch?v=Lj_zKC5BR64&t=16s This
video] has a demo of eepitch blocks.

The main starting point of eev is [http://angg.twu.net/eev-intros/find-eev-quick-intro.html this tutorial] (accessible by `M-x find-eev-quick-intro' or `M-5 M-j').

Home page: http://angg.twu.net/#eev (by EduardoOchs).

== Getting Help ==

There are several channels to get help:

* a mailing list: http://lists.nongnu.org/mailman/listinfo/eev
* InternetRelayChat channels: #eev and #emacs on freenode (chat with "edrx" there).


Everything below this point was written by ThierryVolpiatto in 2013. Some things may be obsolete!


== Build a TOC for your files ==

EevMode is a great tool to build table of contents of your files.

Be sure of course to have Eev installed correctly,([http://angg.twu.net/eev-article.html]) 

if you find `eev-mode' too invasive,

(it can have some strange effect, like reverting versioned files with VC become impossible)

you can set M-e globally, like that you can use eev links even when `eev-mode' is turned off.

* set M-e Globally:

<pre>

(global-set-key (kbd "M-e") 'eek-eval-sexp-eol) 

</pre>

* Add at end of your file:

<pre>

;; Local Variables:
;; eev-comment-prefix: ";"
;; ee-anchor-format: "«%s»"
;; End:

</pre>

<u>Note</u>: `eev-comment-prefix' is the comment string you use for this file (elisp ==> %%;)%%

To make the little green glyph, turn on `eev-mode', then hit M-,

and at prompt enter < < or > >.

(Of course you set `ee-anchor-format' as you want)

<u>Now save your file, kill buffer and reopen your file.</u>

Now when you write an entry like:

;; «title-of-section» (to ".title-of-section")

You are able to write an entry in your index at beginning of file like:

;; «.title-of-section» (to "title-of-section")

To write that, just write:

;; title of section

And then hit M-, (with the cursor on the line) using this code:

* Code to tag eev entry in a file:

<pre>

(defun tv-eev-tag-entry ()
  "Tag entry in file with eev glyph"
  (interactive)
  (if (and ee-anchor-format
           eev-comment-prefix)
      (let ((entry (replace-regexp-in-string (format "^[%s ]+"
                                                     eev-comment-prefix)
                                             ""
                                             (thing-at-point 'line)))
            (new-entry))
        (setq entry (replace-regexp-in-string "\n" "" entry))
        (setq new-entry (replace-regexp-in-string " " "-" entry))
        (end-of-line)
        (re-search-backward entry)
        (delete-region (point) (line-end-position))
        (insert (concat (format ee-anchor-format new-entry)
                        " (to \"." new-entry "\")")))
      (message "Did you forget to set up ee-anchor-format and eev-comment-prefix?")))

(global-set-key (kbd "C-M-,") 'tv-eev-tag-entry)

</pre>


So on one or the over link, when you hit M-e you will move to index or your entry.

That's cool but if you have a file with hundred of lines and many entries , it will be a big work to

write an index.

* Write at the beginning of your file: (where you want your TOC)

<pre>

;; (tv-ee-index-create)

</pre>

And eval it with M-e.

It will create your index or update it if you made some changes in your file.

* Here is the code of `tv-ee-index-create':

<pre>
(defmacro *string (str num)
  "* a string with a number"
  `(let ((str-lis))
    (dotimes (n ,num)
      (push ,str str-lis))
    (mapconcat #'(lambda (i) i) str-lis "")))

(defun tv-ee-index-create ()
  "Create or update an index of all tagged entries found in file.
Put the definition of function in comment at start of index
and eval it with \"M-e\""
  (flet ((create ()
           (let ((entry-list nil)
                 (new-entry nil)
                 (start-pos)
                 (end-pos))
             (forward-line)
             (insert (concat (*string eev-comment-prefix 4)
                             (format ee-anchor-format "INDEX") "\n"))
             (setq start-pos (point))
             (while (not (eobp))
               (forward-line 1)
               (when (re-search-forward (concat (format "^%s*"
                                                        eev-comment-prefix)
                                                " *"
                                                (format ee-anchor-format ".+")) nil t)
                 (setq new-entry
                       (replace-regexp-in-string (format "%s* *" eev-comment-prefix)
                                                           ""
                                                           (match-string 0)))
                 (push new-entry entry-list)))
             (setq entry-list (reverse entry-list))
             ;; we have now a list with elmts like «elmt»
             (goto-char start-pos)
             (dolist (i entry-list)
              (let ((new-entry (substring i 1 (1- (length i)))))
                (insert (concat (*string eev-comment-prefix 3)
                                " "
                                (format ee-anchor-format
                                        (concat "." new-entry))
                                (concat " (to \""
                                        new-entry
                                        "\")"
                                        "\n")))))
             (setq end-pos (point))
             (and (fboundp 'align-cols)
                  (align-cols start-pos end-pos 3))
             (insert "\n")
             (insert (concat (*string eev-comment-prefix 3)
                             "==UPDATE-EEV-BOUNDARY== ;; (Don't delete this line!)\n"))))
         (update ()
           (forward-line)
           (let ((beg (point))
                 (end))
             (when (re-search-forward (format "^%s\\{3\\}==UPDATE-EEV-BOUNDARY==" eev-comment-prefix) nil t)
               (end-of-line)
               (setq end (point)))
             (delete-region beg end)
             (create))))
    (let ((action))
      (save-excursion
        (if (re-search-forward (format "^%s\\{3\\}==UPDATE-EEV-BOUNDARY==" eev-comment-prefix) nil t)
            (setq action 'update)
            (setq action 'create)))
        (when (and ee-anchor-format
                   eev-comment-prefix)
          (funcall action)))))


</pre>

<u>Note</u>: To have a nice index install http://www.emacswiki.org/emacs/align.el

You should have now a file indexed like:

Lisp:AnythingConfigThierryVolpiatto.el

Have fun!

-- ThierryVolpiatto

----

This page needs more informations to explain what it is useful for,
etc.


----
CategoryHypermedia CategoryShell CategoryRegion CategoryProgrammerUtils CategoryModes CategoryMenus CategoryJournaling CategoryExternalUtilities CategoryHypermedia CategoryHelp CategoryNavigation
