Let's see how things are organized in the Git repository.  We will focus on the master branch.

== Build configuration ==

This is not very interesting. It's a lot of stuff that makes Emacs
compile and run on many platforms and architectures.

Emacs --like a lot of GNU projects-- use the GNU autotools.


* <b>autogen.sh</b> --- Little script that checks you have the right version
                 of autotools to build the configure script.

* <b>autogen/</b> --- Some pre-built generated files for autoconf. See
               README inside.

* <b>config.bat</b> --- Configuration script for MSDOS. All I can say is
                 scripting on MSDOS doesn't seem very fun.

* <b>configure.ac, m4/</b> --- Source file used by autoconf to generate the
      configure script. Pretty hairy.

* <b>GNUmakefile</b> --- From the file headers: This GNUmakefile is for GNU
                  Make.  It is for convenience, so that one can run
                  'make' in an unconfigured source tree.  In such a
                  tree, this file causes GNU Make to first create a
                  standard configuration with the default options, and
                  then reinvokes itself on the newly-built Makefile.
                  If the source tree is already configured, this file
                  defers to the existing Makefile.

* <b>make-dist</b> --- Script to make a release tarball.

* <b>Makefile.in</b> --- The makefile not yet processed by autotools.

I recommand reading the INSTALL.REPO if you want to build the git
`master' branch. Basically, if you have all dependancies to build the default
Emacs, run:

<pre>
$ make # does the needed autogen, configure, make with default settings
$ ./src/emacs -Q # run it!
</pre>

I recommend using <code>-jPROC</code> flag for make where <code>PROC</code> is the number of CPU
core you have in order to speed up the compilation.

== Emacs core ==

The core of Emacs is written in C.

* <b>lib</b> --- Source of some libraries used by Emacs
* <b>lib-src</b> --- Source of external utilities (etags, hexl, ...)
* <b>src</b> --- Source of the Emacs executable

=== Lisp objects ===

Let's look at <code>src/lisp.h</code> for fundamental definitions.

A Lisp object (<code>Lisp_Object</code>) is basically a number (an integer). For 32bits Lisp_Object, in hexadecimal:

0xAAAAAAAB


This number is split in 2 parts in terms of bits:
* a value (A), length is the number of bits in type minus number of tag bits
* a tag (B), length is 2 or 3 bits

The value is either a memory address or an integer i.e. the <code>fixnum</code>
Lisp type. The tag indicates the type of the value.

On my 64bit build of Emacs, a Lisp object is stored on a 64bits
signed integer which is called (typedef'ed to) <code>EMACS_INT</code>.

Everytime an object is allocated its address is aligned to 8
bytes. That way the 3 least significant bits are always 0 and thus
can be used for the tag. The allocation code is in <code>src/alloc.c</code>.

The tag is 3 bit long and thus can have 8 different values. The value
uses the remaining bits. Integers use another 1 bit of the 3 tag bits.

This technique makes integer handling fast but has the downside of
limiting the available range of integers. This is problematic on
32bit systems where the point in a buffer can't go past a 2^28
(256MB).

=== Lisp types ===

See <code>enum Lisp_Type</code> in <code>lisp.h:243</code>. It's the value of each tag.

* Integer
* Symbol
* Misc. (see <code>enum Lisp_Misc_Type</code>)
* String
* Vector-like
* Cons
* Float

Two objects are equal (with <code>EQ(a, b)</code>) if both their <code>Lisp_Object</code>
values are equal.

There are several macros defined to extract the relevant data from a
<code>Lisp_Object</code>.

* <code>XTYPE(x)</code> returns the tag (<code>enum Lisp_Type</code>)
* <code>XINT(x)</code> returns the <code>EMACS_INT</code> value
* <code>XUINT(x)</code> returns the <code>EMACS_UINT</code> value
* <code>XCONS(x)</code> returns a <code>struct Lisp_Cons*</code>
* <code>XVECTOR(x)</code> returns a <code>struct Lisp_Vector*</code>
* <code>XSTRING(x)</code> returns a <code>struct Lisp_String*</code>
* <code>XSYMBOL(x)</code> returns a <code>struct Lisp_Symbol*</code>
* <code>XFLOAT(x)</code> returns a <code>struct Lisp_Float*</code>
* <code>XMISC(x)</code> returns a <code>union Lisp_Misc*</code>
* <code>XMARKER(x)</code> returns a <code>struct Lisp_Marker*</code>
* <code>XOVERLAY(x)</code> returns a <code>struct Lisp_Overlay*</code>
* <code>XSAVE_VALUE(x)</code> returns a <code>struct Lisp_Save_Value*</code>
* <code>XPROCESS(x)</code> returns a <code>struct Lisp_Process*</code>
* <code>XWINDOW(x)</code> returns a <code>struct window*</code>
* <code>XTERMINAL(x)</code> returns a <code>struct terminal*</code>
* <code>XSUBR(x)</code> returns a <code>struct Lisp_Subr*</code>
* <code>XBUFFER(x)</code> returns a <code>struct buffer*</code>
* <code>XCHAR_TABLE(x)</code> returns a <code>struct Lisp_Char_Table*</code>
* <code>XSUB_CHAR_TABLE(x)</code> returns a <code>struct Lisp_Sub_Char_Table*</code>
* <code>XBOOL_VECTOR(x)</code> returns a <code>struct Lisp_Bool_Vector*</code>

There's a bunch of type predicates macros:

* <code>INTEGERP(x)</code> checks for float or int
* <code>NILP(x)</code>
* <code>SYMBOLP(x)</code>
* <code>STRINGP(x)</code>
* <code>CONSP(x)</code>
* <code>FLOATP(x)</code>
* <code>VECTORP(x)</code>

* <code>PROCESSP(x)</code>
* <code>WINDOWP(x)</code>
* <code>TERMINALP(x)</code>
* <code>SUBRP(x)</code>
* <code>BUFFERP(x)</code>
* <code>FRAMEP(x)</code>

* <code>MISCP(x)</code>
* <code>VECTORLIKEP(x)</code>
* <code>OVERLAYP(x)</code>
* <code>MARKERP(x)</code>
* <code>SAVE_VALUEP(x)</code>
* <code>IMAGEP(x)</code>

=== Defining functions ===

There is a <code>DEFUN</code> macro in <code>lisp.h:1987</code>. Have a look at the manual,
it's pretty well written. [[Manual:Writing Emacs Primitives]] (elisp)

=== Idioms ===

==== Iterating on a list ====

<pre>
Lisp_Object tail;

for (tail = list; CONSP (tail); tail = XCDR (tail))
  {
    List_Object e = XCAR (tail); /* current element */
    /* ... */
  }
</pre>

=== Configure script and build flags ===

If you know how to write basic shell scripts you're good to go. This
is a crash course in autoconf for Emacs. Have a look at autoconf doc
for more.

==== Adding a enable/disable configure flag ====

Open <code>configure.ac</code>, it's a big shell script template
that is processed by autoconf to generate the actual configure.sh
script.

Look for <code>OPTION_DEFAULT_ON</code> or <code>OPTION_DEFAULT_OFF</code>
depending on if you want your option to be turn on or off by default.

The syntax is <code>OPTION_DEFAULT_ON([thing],[description])</code> where:
* <code>thing</code> is the thing you want to turn on or off (<code>--with-thing</code>, <code>--without-thing</code>)
* <code>description</code> is a description of the thing.

This macro will define a <code>with_thing</code> shell variable
available in the rest of the script. Its value will be either "yes" or
"no".

The convention is later in the script:

* To first to check if <code>$with_thing</code> is <code>yes</code>
* In which case you check if you can actually enable it for emacs on the current system
* If that's the case, set a <code>HAVE_THING</code> variable to yes. If you can't enable it, set it to no.
* Add the corresponding <code>echo</code> close the the end of the script. Look for "Does Emacs use" in <code>configure.ac</code>.

==== Exporting a C macro ====

If you need to export something to make it available in the C sources
(as a define macro written in <code>src/config.h</code>), use:

<pre>
AC_DEFINE(YOUR_MACRO, value, [Purpose of the macro])
</pre>

This will define <code>YOUR_MACRO</code> to the verbatim
<code>value</code>. In case you want to export the content of a shell
variable (expand it), simply putting <code>$value</code> <b>will not
work</b>, you have to use:

<pre>
AC_DEFINE_UNQUOTED(YOUR_MACRO, "$your_variable", [ description ])
</pre>

==== Exporting a shell variable to rest of autoconf machinery ====

If you need to export a shell variable to <code>src/Makefile.in</code>
(the file that is processed by autoconf to generate the actual
Makefile) you need to use

<pre>
AC_SUBST(YOUR_SHELL_VAR)
</pre>

This will replace any occurence of <code>@YOUR_SHELL_VAR@</code> in
files processed by autoconf with the content of the shell var. If you
look at src/Makefile.in for example, you can see:

<pre>
LIBZ = @LIBZ@
</pre>

This define a Makefile variable to the value of the shell variable
defined earlier in <code>configure.ac</code>.

==== Summary ====

<pre>
# first define the configure option
OPTION_DEFAULT_ON([thing],[description])

# ...

# Thing support
HAVE_THING=no
## declare here other variable you need
## like additional build flags, etc.
##
## the convention is to use
##  - THING_OBJ for additional object files (use AC_SUBST to export!)
##  - LIBTHING for additional librares to add to the linker flags (use AC_SUBST to export!)

if test "${with_thing}" != "no"; then
 # do your check to see if you can actually enable it
 HAVE_THING=yes # (lets assume you can)
 # define
fi

if test "${HAVE_THING}" = yes; then
  # now you *have* to enable Thing!
  # AC_SUBST, AC_DEFINE, etc usually go here
  AC_DEFINE(HAVE_THING, 1, [Define to 1 if Thing enabled])
fi

# ...

# add a "summary line" printed at the end of configuration
echo "  Does Emacs has Thing?                 ${HAVE_THING}"
</pre>
